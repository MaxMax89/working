<?php
//Различие между одинарными и двойными кавычками обусловлено тем, насколько интенсивной интерпретации подвергаются в среде PHP символы, заключенные в кавычки, перед созданием самой строки. Если строка заключена в одинарные кавычки, то не выполняется почти никакая интерпретация, а если строка заключена в двойные кавычки, то в среде PHP осуществляется подстановка значений всех переменных, которые указаны в строке, а также выполняется замена некоторых специальных символьных последовательностей, которые начинаются с символа обратной косой черты (\).

$count = 13;

 $string_1 = 'В строке \'Hello World!\' $count символов.<br>';
 $string_2 = "В строке \"Hello World!\" $count символов.<br>";

   
   echo $string_1;
   echo $string_2;
//------------------------------------------------------------------------------
                             //Подстановка значений с использованием фигурных скобок.

   $sport_1 = 'Волей';
   $sport_2 = 'баскет'; 
       // Фигурные скобки говорят о том что нужно вычислить переменную.
    $sport_1 = "Я люблю играть в $sport_1бол.<br>";    // Не правильная.
    $sport_2 = "Я люблю играть в {$sport_2}бол.<br>";  // Правильная.

        echo $sport_1;
        echo $sport_2;
                   //Общее правило состоит в том, что если за открывающей фигурной скобкой ({) непосредственно следует символ $, то интерпретатор PHP вычисляет значение выражения с именем переменной вплоть до закрывающей фигурной скобки (}), а затем подставляет результирующее значение в строку. (Если требуется, чтобы в строке появилось литеральное значение {$, это можно обеспечить, поставив перед каждым из этих символов обратную косую черту, \).
   

    //-------------------------------------------------------------------------------
                           //Символы и индексы символов в строках

    //В отличие от некоторых других языков программирования в языке PHP нет отдельного символьного типа, не совпадающего со строковым типом. Вообще говоря, функции, которые требуют в других языках применения символьных фактических параметров, в языке PHP рассчитаны на получение строк с длиной 1.

//Выборка отдельных символов из строки может осуществляться путем указания порядкового номера символа, начинающегося с нуля, который должен быть указан в фигурных скобках непосредственно за именем строковой переменной. Такие символы фактически представляют собой односимвольные строки. Например, выполнение следующего кода:



  $my_string = "Dubled";

  for ($index=0; $index < strlen($my_string); $index++) 
  { 
       $char = $my_string{$index};
       print("$char$char");
  }
       //----------------------------------------------------------------------------------------
                         //Операции со строками
      
      //В языке PHP предусмотрены две строковые операции: операция со знаком операции точка (.), или операция конкатенации, и операция со знаком операции точка и знак равенства (.=), или операция конкатенации и присваивания.
 

  $str_1 = "<br>"."Это часть";
  $str_2 = "строки";

   // Конкатенация строк
 echo $str_1." простой ".$str_2;
   // Конкатенация и присваивание
  $str_1 .= " простой ";
  $str_1 .= $str_2;
  echo $str_1;

                 //Синтаксическая структура вложенного документа (Heredoc)
//Кроме синтаксических структур строк в одинарных и двойных кавычках, в языке PHP предусмотрен еще один способ задания строки, называемый синтаксической структурой вложенного документа (Heredoc). Как оказалось, подобная синтаксическая структура является весьма удобным средством задания больших фрагментов текста, подставляемого с помощью переменных, поскольку избавляет пользователя от необходимости обозначать внутренние кавычки с помощью специальных символов. Такой способ особенно удобен при создании страниц, которые содержат формы HTML.

//Знаком операции, применяемом в синтаксической структуре вложенного документа, является (<<<). За этим знаком должна непосредственно следовать метка (не заключенная в кавычки), которая обозначает начало многострочного текста. Интерпретатор PHP продолжает включать в состав значения переменной следующие строки до тех пор, пока снова не появится эта же метка в начале строки. За заключительной меткой может следовать необязательная точка с запятой, а какие-либо другие символы после метки не допускаются.

$string = <<<EOT
<form method="post" action="{$_SERVER['PHP_SELF']}">
    <input type="text" name="login" placeholder="Введите имя..."><br>
       <input type="password" name="password" placeholder="Введите пароль..."><br>
       <input type="submit" value="Отправить">
</form>
EOT;

 echo $string;

                                     //Проверка строк

                //strlen()  функция для проверки длинны строк.

 $en_str = "Hello world";
 $rus_str = "простая строка";

 echo $en_str." - ".strlen($en_str)." символов<br>";
 echo $rus_str." - ".mb_strlen($rus_str, 'UTF8')." символов<br>";

    //Во втором случае в строке есть русские символы, которые кодируются 2 байтами (UTF-8). Чтобы избежать проблем в дальнейшем при работе со строковыми функциями, в PHP следует использовать функции для многобайтных кодировок, начинающихся с префикса mb_. Это значит, что в предыдущем примере надо заменить функцию strlen() на mb_strlen() и явно указать кодировку:

                                                 //Поиск символов и подстрок
//Следующий вопрос, касающийся строк, заключается в том, что они содержат. Например, функция strpos() [mb_strpos()] позволяет найти номер позиции конкретного символа в строке, если таковой имеется:


$enstr = "Hello world!";
 
 echo  "символ 'l' :". strpos($enstr, 'l')."<br>";  //Поиск ведется с начала строки
 echo  "символ 'l' :". strrpos($enstr, 'l')."<br>"; //Поиск ведется с конца строки


                                                //Поиск
 //Функция strstr() [mb_strstr()] принимает в качестве параметров строку, в которой должен быть выполнен поиск, и искомую строку (в указанном порядке). В случае успеха данная функция возвращает часть строки, которая начинается с первого вхождения искомой строки (и включает искомую строку). Если такая строка не найдена, функция возвращает ложное значение. В следующем фрагменте кода приведены примеры применения этой функции:
 
  
 $str = "Привет мир!";
 $find_str = "мир";

  echo "Подстрока '<b>$find_str</b>' в исходной строке ".strstr($str, $find_str)."<br>";

  //Так же как и функция strcmp(), функция strstr() имеет версию, нечувствительную к регистру, которая имеет имя stristr() [mb_stristr] (буква i в этом имени является сокращением от слова insensitive — нечувствительный). Функция stristr() идентична функции strstr() во всех отношениях, за исключением того, что при сравнении строчные буквы рассматриваются как прописные аналоги.

                                                   //Выборка подстроки 
 //Наиболее простой способ выборки части строки состоит в применении функции substr() [mb_substr()], которая возвращает новую строку, содержащую часть подпоследовательности символов из старой строки. В качестве параметров функция substr() принимает строку (из которой осуществляется выборка подстроки), целое число (позиция, с которой начинается требуемая подстрока) и необязательный целочисленный третий параметр, который задает длину требуемой подстроки. Если третий параметр не задан, то подразумевается, что подстрока продолжается до конца строки. (Следует помнить, что и при использовании этой функции нумерация позиций в строке начинается с нуля, а не с единицы, как и во всех параметрах функций PHP, которые обозначают числовые позиции в строках.)

  $www = "012мир678";

   echo mb_substr($www, 3, 3, 'UTF8')."<br>";  // мир
   echo mb_substr($www, -6, 3, 'UTF8')."<br>"; // мир
   echo mb_substr($www, 3, 4, 'UTF8')."<br>";  // мир6

                                       //Удаление пробелов и символов табуляции из строк

//Функция str_replace() позволяет заменить все вхождения заданной конкретной подстроки другой строкой. Эта функция принимает три параметра: строка, в которой должен быть выполнен поиск, подстрока, подлежащая замене после ее обнаружения, и строка, которая должна применяться для замены. Рассмотрим следующий пример:

$qqq = "один четыре три";


echo str_replace(четыре, два, $qqq)."<br>";  // один два три


//функция substr_replace() выбирает часть, подлежащую замене, по ее абсолютной позиции. Эта функция принимает до четырех параметров: строка, в которой должна быть выполнена замена, строка, применяемая в качестве замены, начальная позиция замены и (в качестве необязательного параметра) длина заменяемой части строки. Рассмотрим следующий пример:


echo substr_replace("AB23EF", "CD", 2, 2)."<br>";  //ABCDEF


$zzz = "DCBA";

 echo strrev($zzz)."<br>"; //ABCD


 //str_repeat() принимает один строковый и один целочисленный параметр и возвращает строку, в которой собрано указанное количество копий строкового параметра:

 $rrr = "bla-";

  echo str_repeat($rrr, 3)."<br>";  // blablabla

                                                 //Функции преобразования регистра букв

//Эти функции позволяют преобразовывать строчные буквы в прописные и наоборот. Функция strtolower() [mb_strtolower()] возвращает строку, в которой все буквы преобразованы в строчные. При этом не имеет значения, содержала ли исходная строка исключительно прописные буквы или прописные и строчные.

$vvv = "Добрый день!";

 echo mb_strtolower($vvv, 'UTF8')."<br>"; 

 //Функция strtoupper() [mb_strtoupper()] возвращает строку, в которой все буквы преобразованы в прописные

 $nnn = "Добрый день!";

  echo mb_strtoupper($nnn, 'UTF8')."<br>";

                                     //Функции введения управляющих символов

//Одним из преимуществ языка PHP является то, что он может применяться дня обмена данными почти с любой системой. Средства подобного рода принято рассматривать как своего рода "программный клей". В этой роли язык PHP применяется для взаимодействия с серверами баз данных, серверами LDAP, для обмена данными через сокеты и само соединение HTTP. Зачастую такое взаимодействие осуществляется путем предварительного создания строки сообщения (наподобие запроса к базе данных), а затем передачи этого сообщения в программу-получатель. Но в программах часто придается особый смысл некоторым символам, и поэтому их приходится преобразовывать в управляющие символы. Это означает, что программе-получателю дается указание рассматривать подобные символы как литеральную часть строки, а не применять к ним специальную обработку.

//ногие пользователи, чтобы справиться с этой проблемой, разрешают использование так называемого "режима магических кавычек", который гарантирует, что кавычки будут преобразованы в управляющие символы перед вставкой строк в базы данных. Но если такой режим обработки является неосуществимым или нежелательным, то приходится использовать добрые старые средства вставки символов обратной косой черты и последующего удаления этих символов.

//Функция addslashes() преобразует одинарные и двойные кавычки, символы обратной косой черты и нуль-символы в управляющие последовательности с помощью символов обратной косой черты, поскольку именно указанные символы обычно приходится преобразовывать в управляющие последовательности при подготовке запросов к базам данных:


//$escapedstring = addslashes("Строка с 'кавычками'.");
//$query = "INSERT INTO test (quote) values ('$escapedstring')";

//$result = mysqli_query($link, $query) or die(mysql_error());


//Выполнение этого кода позволяет предотвратить ошибочную интерпретацию оператора SQL, при которой строка рассматривалась бы как заканчивающаяся прямо перед буквой 'к'. А после выборки этих данных необходимо воспользоваться функцией stripslashes() для удаления символов обратной косой черты.

//Функция quotemeta() преобразует в управляющие последовательности более широкий набор символов. Все эти символы обычно имеют особый смысл в командной строке Unix: " . ", " ' ", " + ", " * ", " ? ", " [ ", " ] ", " ^ ", " ( ", " $ " и " )". Например, выполнение следующего кода:


$ppp = "Эти символы ($, *, ^) нужно преобразовать.";

echo quotemeta($ppp)."<br>";  //Эти символы \(\$, \*, \^\) нужно преобразовать\.

                                    //Функции вывода на внешнее устройство и в строку

  //Основными конструкциями, применяемыми для вывода, являются print и echo, которые подробно рассматривались ранее. Стандартный способ вывода значений переменных на внешнее устройство состоит в том, чтобы включить имена этих переменных в строку с двойными кавычками (при обработке которой интерпретатором происходит подстановка значений переменных), а затем передать эту строку в конструкцию print или echo.

//Если требуется еще более точно отформатированный вывод, то можно воспользоваться предоставляемыми языком PHP функциями printf() и sprintf(). Эти две функции принимают одинаковые параметры: специальную строку формата, за которой следует произвольное количество других параметров, подставляемых в нужные места в строке формата для получения результата. Единственное различие между функциями printf() и sprintf() состоит в том, что printf() отправляет результирующую строку непосредственно на внешнее устройство, применяемое для вывода, a sprintf() возвращает результирующую строку в качестве результата своего выполнения.

//Несколько слов для опытных программистов, работающих на языке C. Эта версия функции sprintf() немного отличается от версии из языка C в том, что функции sprintf() не требуется предоставлять распределенную строку, в которую должна осуществляться запись, поскольку интерпретатор PHP распределяет память для результирующей строки от имени пользователя.

//Основная сложность, связанная с использованием этих функций, состоит в правильном определении строки формата. Каждый символ, находящийся в строке формата, появляется в результирующем значении в непосредственном виде, за исключением символов % и символов, которые сразу же следуют за этими символами. Символ % обозначает начало спецификации преобразования, которая указывает, как вывести на внешнее устройство один из параметров, который следует за строкой формата.

//После знака % находятся пять элементов, входящих в состав спецификации преобразования, которые описаны ниже, причем некоторые из них являются необязательными: заполнение, выравнивание, минимальная ширина, точность и тип:

//Для указания на то, является ли число отрицательным, применяется необязательное обозначение в виде знака "минус" (-).

//Единственный (необязательный) символ заполнения представляет собой либо 0, либо пробел ( ). Этот символ используется для заполнения любого пространства, которое при его отсутствии осталось бы незаполненным, но на выделении которого настаивал пользователь (задавая слишком большое значение параметра минимальной ширины). Если этот символ заполнения не задан, то по умолчанию происходит заполнение пробелами.

//Необязательный символ выравнивания (-) показывает, должно ли выводимое значение быть выровнено по левому или по правому краю. Если этот символ задан, то значение будет выровнено по левому краю, а при его отсутствии применяется выравнивание по правому краю.

//Необязательное числовое значение минимальной ширины, которое указывает, какое минимальное количество позиций должно занимать выводимое значение. (Если для вывода значений требуется больше символьных позиций, чем указано, то выводимое значение выходит за эти пределы.)

//Необязательный спецификатор точности, оформляемый как точка (.), за которой следует число. Спецификатор указывает, с какой точностью, измеряемой количеством десятичных позиций после точки, должно быть выведено число с плавающей точкой двойной точности. (Применение данной спецификации не оказывает никакого влияния при выводе данных, отличных от чисел с плавающей точкой двойной точности.)

//Единственный символ, указывающий, как должен интерпретироваться тип значения. Символ f указывает, что значение должно быть выведено как число с плавающей точкой двойной точности, символ s указывает, что вывод значения должен осуществляться в виде строкового, а остальные возможные символы (b, c, d, o, x, X) говорят о том, что значение должно интерпретироваться как целочисленное и выводиться в различных форматах. Этими форматами являются b, который обозначает вывод в формате двоичных чисел, c - обусловливающий вывод символа с соответствующим значением кода ASCII, o - который требует вывода в формате восьмеричных чисел, x - для вывода в формате шестнадцатеричных чисел (с буквенными обозначениями цифр в нижнем регистре), и X - для вывода шестнадцатеричных чисел, в которых в качестве буквенных обозначений цифр используются прописные буквы.

//Ниже приведен пример вывода одного и того же числа с плавающей точкой двойной точности несколькими разными способами:




    
$value = 3.14159;
printf ("%f<br> %10f<br> %-10f<br> %2.2f", $value, $value, $value, $value)."<br>"; //3.141590
                                                                                   //3.141590
                                                                                   //3.141590
                                                                                   //3.14


                                //Функции, предназначенные для оценки подобия строк


//Функция levenshtein() принимает в качестве параметров две строки и возвращает данные о том, какое минимальное количество операций добавления, удаления и замены символов необходимо для преобразования одной строки в другую.

 echo levenshtein(123, 124)."<br>";  //1 
 echo levenshtein(123, 156)."<br>";  //2
 echo levenshtein(123, 789)."<br>";  //3


                               //Функции синтаксического анализа и разбиения на лексемы
//Иногда возникает необходимость обеспечить в программе разбиение строк на компоненты, руководствуясь собственным определением того, что должно рассматриваться в качестве компонента. Процесс разделения длинной строки на части называют разбиением на лексемы. В частности, такой процесс входит в состав общей процедуры интерпретации или компиляции любой компьютерной программы, включая программу на языке PHP. В языке PHP для этой цели предусмотрена специальная функция — strtok().

//Функция strtok() принимает два параметра: строку, предназначенную для разбиения на лексемы, и строку, содержащую все разграничители (символы, которые рассматриваются как границы между лексемами). При первом вызове используются оба параметра и функция возвращает строковое значение, представляющее собой первую лексему. Для выборки последующих лексем выполняется такой же вызов, но параметр с исходной строкой исключается. Функция запоминает адрес строки, заданной в первом параметре, и использует ее в качестве текущей строки. Кроме того, эта функция запоминает, в каком месте была прекращена обработка при предыдущем вызове


 $token = strtok("open-source HTML-embedded server-side Web scripting", " "); 

while($token)
{
    echo $token."<br>";                //open-source
                                       //HTML-embedded
                                       //server-side
                                       //Web
                                       //scripting
    $token = strtok(" ");                 
}

                //Разбиение исходной строки осуществляется в том месте, где находится каждый пробел.

//Функция strtok() формирует лексемы одну за другой. Можно также воспользоваться функцией explode(), которая выполняет примерно аналогичные действия, не считая того, что она сохраняет сразу все лексемы в одном массиве. После получения лексем, представленных в виде массива, с ними можно выполнять любые операции, включая сортировку.

//Функция explode() принимает два параметра: разделительную строку и строку, которая должна быть разделена на лексемы. Эта функция возвращает массив, каждый элемент которого представляет собой подстроку, находящегося между экземплярами разделителя в строке, подлежащей разделению. Рассмотрим следующий пример:


$explode_result = explode("AND", "one AND a two AND a three");

//который приводит к получению массива $explode_result, содержащего три элемента, каждый из которых представляет собой строку: "one ", " a two " и " a three". В данном конкретном примере не встречается ни одной прописной буквы в какой-либо из строк, содержащихся в массиве, поскольку разделитель AND не присутствует в результате.

//Разделительная строка, применяемая в функции explode(), в значительной степени отличается от строки с разграничителями, используемой в функции strtok(). Разделитель представляет собой полноценную строку, поэтому все символы этой строки должны быть найдены в исходной строке в том же порядке, что и в разделителе, чтобы можно было считать этот разделитель обнаруженным.

//С другой стороны, строка с разграничителями в функции strtok() задает множество отдельных символов, каждый из которых рассматривается как разграничитель. Это означает, что функция explode() действует более избирательно, но в большей степени подвержена нарушениям в работе. В частности, если в длинной строке будет случайно пропущен даже единственный пробел или символ обозначения конца строки, входящий в состав разделителя, то может быть нарушена вся работа этой функции.


?>